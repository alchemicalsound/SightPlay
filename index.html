<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>SightPlay</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #303236;
      color: #e2e8f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      padding: 1.5rem;
    }
    h1 { font-size: 1.6rem; margin-bottom: 0; text-align: center; }
    .subtitle { font-size: .7rem; color: #94a3b8; text-align: center; margin-bottom: .5rem; }

    .card {
      background: rgba(139, 139, 139, 0.4);
      border: 1px solid rgba(148,163,184,.2);
      border-radius: 1rem;
      padding: .3rem 1.25rem;
      width: min(540px, 100%);
      display: flex;
      flex-direction: column;
      gap: .1rem;
    }
    .selectors-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: .8rem 1rem;
    }
    .selectors-grid.hidden { display: none; }
    @media (max-width: 560px) {
      .selectors-grid { grid-template-columns: 1fr; }
    }
    .group-label { font-size: .7rem; color: #94a3b8; margin-bottom: .25rem; }

    .opt-btn {
      background: rgba(15,23,42,.2);
      border: 1px solid rgba(148,163,184,.1);
      color: #e2e8f0;
      border-radius: .6rem;
      padding: .35rem .7rem;
      font-size: .7rem;
      cursor: pointer;
      transition: .12s ease;
      white-space: nowrap;
    }
    .opt-btn.active { background: #38f8b8; color: #0f172a; border-color: #38f8b8; }

    .compact-row {
      display: flex;
      gap: 0;
      background: rgba(15,23,42,.1);
      border-radius: .45rem;
      overflow: hidden;
      width: fit-content;
      max-width: 100%;
      flex-wrap: wrap;
    }
    .compact-row .opt-btn {
      border-radius: 0;
      border-left: 1px solid rgba(148,163,184,.06);
      padding: .28rem .5rem;
      font-size: .65rem;
    }
    .compact-row .opt-btn:first-child {
      border-left: none;
    }

    .deg-acc-row {
      display: flex;
      gap: .4rem;
      align-items: flex-start;
      flex-wrap: wrap;
    }
    .deg-compact-row,
    .acc-compact-row {
      display: flex;
      gap: 0;
      flex-wrap: nowrap;
      border-radius: .4rem;
      overflow: hidden;
      background: rgba(15,23,42,.1);
    }
    .deg-compact-row .opt-btn,
    .acc-compact-row .opt-btn {
      border-radius: 0;
      padding: .25rem .4rem;
      font-size: .6rem;
      line-height: 1.1;
      border-left: 1px solid rgba(148,163,184,.06);
    }
    .deg-compact-row .opt-btn:first-child,
    .acc-compact-row .opt-btn:first-child {
      border-left: none;
    }

    .status { text-align: center; font-weight: 600; margin-top: .25rem; }
    .good { color: #22c55e; }
    .bad { color: #f43f5e; }
    .mid { color: #eab308; }
    .small { font-size: .7rem; color: #94a3b8; }
    .staff-wrapper { overflow-x: auto; max-width: 100vw; }
    #staff { background: rgba(15,23,42,.2); border-radius: 1rem; display: block; }

    button {
      background: #ff2f2f33;
      color: #ffffff8f;
      border: none;
      border-radius: .75rem;
      padding: .5rem .9rem;
      font-weight: 600;
      cursor: pointer;
    }
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: .4rem;
      justify-content: center;
      width: min(540px, 100%);
      align-items: center;
    }

    .options-panel {
      width: min(540px, 100%);
    }

    .donate-panel {
      width: min(540px, 100%);
      margin-top: .5rem;
    }
    .donate-panel.hidden {
      display: none;
    }

    .gate-inline {
      display: flex;
      gap: .5rem;
      align-items: center;
    }
    .gate-inline input[type="range"] {
      width: 110px;
    }
    #meter {
      width: 110px;
      height: 24px;
      background: #1f2937;
      border-radius: 6px;
      display: block;
      margin-top: .3rem;
    }

    input[type="range"] {
      -webkit-appearance: none;
      background: transparent;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 4px;
      background: #1f2937;
      border-radius: 999px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #475569;
      margin-top: -5px;
      cursor: pointer;
    }
    input[type="range"]::-moz-range-track {
      height: 4px;
      background: #1f2937;
      border-radius: 999px;
    }
    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #475569;
      cursor: pointer;
      border: none;
    }

    .range-inline {
      display: flex;
      gap: .3rem;
      align-items: center;
    }
    .range-inline input[type="range"] {
      width: 80px;
    }
    .mini-btn {
      background: rgba(15,23,42,.4);
      border: 1px solid rgba(148,163,184,.2);
      border-radius: .35rem;
      padding: .15rem .35rem;
      font-size: .6rem;
      cursor: pointer;
    }

    /* diapas√≥n columna izquierda */
    #fretboardBox {
      margin-top: .5rem;
      background: rgba(15,23,42,.1);
      border-radius: .5rem;
      display: none;
      position: relative;
      width: 580px;
      padding-left: 70px; /* OFFSET de columna izquierda */
      box-sizing: content-box;
    }
    #fretboard {
      display: block;
    }
    #fretLeftCol {
      position: absolute;
      top: 6px;
      left: 6px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      pointer-events: auto;
    }
    #fretTuners {
      position: static;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .string-tuner {
      width: 54px;
      background: #1f2937;
      border: 1px solid rgba(148,163,184,.35);
      color: #e2e8f0;
      font-size: .55rem;
      border-radius: .25rem;
      padding: 0 .15rem;
    }
    #fretWidthBtn {
      background: rgba(15,23,42,.6);
      border: 1px solid rgba(148,163,184,.4);
      border-radius: .35rem;
      padding: .2rem .4rem;
      font-size: .55rem;
      cursor: pointer;
      width: 54px;
      text-align: center;
    }

    .bpm-box {
      display: flex;
      align-items: center;
      gap: .3rem;
      font-size: .65rem;
      color: #94a3b8;
    }
    .bpm-box input {
      width: 56px;
      background: #1f2937;
      border: 1px solid rgba(148,163,184,.2);
      border-radius: .35rem;
      color: #e2e8f0;
      padding: .15rem .35rem;
      font-size: .65rem;
    }
  </style>
</head>
<body>
  <h1>SightPlay</h1>
  <div class="subtitle">By lALO</div>

  <div class="card">
    <div id="status" class="status mid" style="margin-top:.1rem;">Pidiendo micr√≥fono‚Ä¶</div>
    <p class="small" id="progress">0 / 0</p>
    <p class="small" id="studyInfo">Tiempo de estudio: 00:00 | Ejercicios completados: 0</p>
  </div>

  <div class="staff-wrapper">
    <canvas id="staff" width="520" height="160"></canvas>
  </div>

  <div id="fretboardBox">
    <div id="fretLeftCol">
      <div id="fretTuners"></div>
      <button id="fretWidthBtn" title="Cambiar ancho del diapas√≥n">‚áÜ</button>
    </div>
    <canvas id="fretboard" width="520" height="110"></canvas>
  </div>

  <div class="controls-row">
    <button id="muteBtn">Mute micr√≥fono</button>
    <button id="playBtn">‚ñ∂Ô∏é Reproducir</button>
    <button id="prevBtn">‚óÄ Nota</button>
    <button id="startBtn">‚ü≤ Inicio</button>
    <button id="loopBtn">Loop: off</button>
    <div class="bpm-box">
      BPM
      <input id="bpmInput" type="number" min="40" max="220" value="115">
    </div>
    <button id="toggleMenuBtn" class="opt-btn">‚öôÔ∏é Opciones</button>
    <button id="toggleDonateBtn" class="opt-btn" style="background:rgba(255,255,255,.05);">‚ô• Donate</button>
  </div>

  <div class="options-panel">
    <div class="selectors-grid hidden" id="selectorsGrid">
      <div>
        <div class="group-label">Instrumento</div>
        <div class="compact-row" id="instGroup">
          <button class="opt-btn" data-value="piano">Piano</button>
          <button class="opt-btn" data-value="guitar">Guitarra</button>
        </div>
      </div>
      <div>
        <div class="group-label">Compases</div>
        <div class="compact-row" id="barsGroup">
          <button class="opt-btn" data-value="1">1</button>
          <button class="opt-btn" data-value="2">2</button>
          <button class="opt-btn" data-value="3">3</button>
          <button class="opt-btn" data-value="4">4</button>
        </div>
      </div>
      <div>
        <div class="group-label">Clave</div>
        <div class="compact-row" id="clefGroup">
          <button class="opt-btn" data-value="treble">Sol</button>
          <button class="opt-btn" data-value="bass">Fa</button>
        </div>
      </div>
      <div>
        <div class="group-label">Comp√°s</div>
        <div class="compact-row" id="tsGroup">
          <button class="opt-btn" data-value="4/4">4/4</button>
          <button class="opt-btn" data-value="3/4">3/4</button>
        </div>
      </div>
      <div>
        <div class="group-label">Tonalidad</div>
        <div class="compact-row" id="keyGroup">
          <button class="opt-btn" data-value="C">C</button>
          <button class="opt-btn" data-value="G">G</button>
          <button class="opt-btn" data-value="F">F</button>
          <button class="opt-btn" data-value="D">D</button>
          <button class="opt-btn" data-value="Bb">Bb</button>
        </div>
      </div>
      <div>
        <div class="group-label">Salto m√°ximo (intervalo)</div>
        <div class="compact-row" id="stepGroup">
          <button class="opt-btn" data-value="1">2¬∞</button>
          <button class="opt-btn" data-value="2">3¬∞</button>
          <button class="opt-btn" data-value="3">4¬∞</button>
          <button class="opt-btn" data-value="4">5¬∞</button>
        </div>
      </div>
      <div>
        <div class="group-label">Rango permitido</div>
        <div class="small">Grave:</div>
        <div class="range-inline">
          <button class="mini-btn" id="minRangeDown">-</button>
          <input id="minRangeSlider" type="range" min="0" max="0" value="0">
          <button class="mini-btn" id="minRangeUp">+</button>
          <span class="small" id="minRangeLabel"></span>
        </div>
        <div class="small" style="margin-top:.35rem;">Aguda:</div>
        <div class="range-inline">
          <button class="mini-btn" id="maxRangeDown">-</button>
          <input id="maxRangeSlider" type="range" min="0" max="0" value="0">
          <button class="mini-btn" id="maxRangeUp">+</button>
          <span class="small" id="maxRangeLabel"></span>
        </div>
      </div>
      <div>
        <div class="group-label">Alteraciones</div>
        <div class="deg-acc-row">
          <div class="deg-compact-row" id="degGroup">
            <button class="opt-btn" data-value="1">I</button>
            <button class="opt-btn" data-value="2">II</button>
            <button class="opt-btn" data-value="3">III</button>
            <button class="opt-btn" data-value="4">IV</button>
            <button class="opt-btn" data-value="5">V</button>
            <button class="opt-btn" data-value="6">VI</button>
            <button class="opt-btn" data-value="7">VII</button>
          </div>
          <div class="acc-compact-row" id="accTypeGroup">
            <button class="opt-btn" data-value="flat">‚ô≠</button>
            <button class="opt-btn" data-value="none">‚Äî</button>
            <button class="opt-btn" data-value="sharp">#</button>
          </div>
        </div>
      </div>
      <div>
        <div class="group-label">Valores / silencios</div>
        <!-- NUEVO: botones de valor -->
        <div class="compact-row" id="noteValuesGroup" style="margin-bottom:.35rem;">
          <button class="opt-btn active" data-value="q" title="Negra">‚ô©</button>
          <button class="opt-btn active" data-value="qr" title="Silencio de negra">ùÑΩ</button>
          <button class="opt-btn" data-value="h" title="Blanca">ùÖû</button>
          <button class="opt-btn" data-value="hr" title="Silencio de blanca">ùÑ∫</button>
        </div>
        <div class="small">Prob. silencio</div>
        <div class="gate-inline" style="margin-top:.15rem;">
          <input id="restProb" type="range" min="0" max="1" step="0.05" value="0">
          <span class="small" id="restProbVal">0%</span>
        </div>
      </div>
      <div>
        <div class="group-label">Armon√≠a</div>
        <div class="compact-row" id="harmGroup">
          <button class="opt-btn" data-value="off">Off</button>
          <button class="opt-btn" data-value="on">On</button>
        </div>
        <div class="small" style="margin-top:.25rem;">Densidad</div>
        <div class="gate-inline" style="margin-top:.15rem;">
          <input id="harmDensity" type="range" min="0" max="1" step="0.1" value="1">
          <span class="small" id="harmDensityVal">1.0</span>
        </div>
        <div class="small" style="margin-top:.25rem;">Tensi√≥n</div>
        <div class="gate-inline" style="margin-top:.15rem;">
          <input id="harmTension" type="range" min="0" max="1" step="0.1" value="0">
          <span class="small" id="harmTensionVal">0.0</span>
        </div>
        <div class="small" style="margin-top:.35rem;">Bloqueo</div>
        <button id="harmLockBtn" class="opt-btn" style="margin-top:.2rem;">Bloq armon√≠a</button>
      </div>
      <div>
        <div class="group-label">Noise gate</div>
        <div class="gate-inline">
          <input id="gateSlider" type="range" min="0.002" max="0.05" step="0.002" value="0.01">
          <span class="small" id="gateVal">0.010</span>
        </div>
        <canvas id="meter" width="110" height="24"></canvas>
        <div class="group-label" style="margin-top:.6rem;">Reverb</div>
        <div class="gate-inline">
          <input id="reverbSlider" type="range" min="0" max="1" step="0.05" value="0.3">
          <span class="small" id="reverbVal">0.30</span>
        </div>
      </div>
    </div>
  </div>

  <div class="donate-panel hidden" id="donatePanel">
    <div class="card">
      <h2 style="font-size:.85rem; margin-top:0; margin-bottom:.4rem;">Apoya este proyecto üíõ</h2>
      <p class="small" style="margin-bottom:.35rem;">Si te sirvi√≥, puedes invitarme un caf√© en PayPal:</p>
      <a href="https://paypal.me/RossAbotManager" target="_blank"
         style="display:inline-block;background:#0070ba;color:#fff;padding:6px 12px;border-radius:6px;
                text-decoration:none;font-size:.7rem;font-weight:600;">
        Donar con PayPal
      </a>
      <div style="margin-top:.7rem; text-align:center;">
        <p class="small" style="margin-bottom:.35rem;">Pago/propina en M√©xico (CoDi):</p>
        <img src="codi-qr.jpg"
             alt="QR CoDi"
             style="width:180px; height:auto; border-radius:.5rem; background:#1f2937; display:inline-block;">
      </div>
      <div style="margin-top:.7rem;">
        <p class="small" style="margin-bottom:.15rem;">Transferencia bancaria directa:</p>
        <p style="font-size:.65rem; line-height:1.3;">
          Nombre: <strong>JOSE EDUARDO CALDERON OTERO</strong><br>
          Banco: <strong>BancoAzteca</strong><br>
          CLABE: <strong>127457013338249836</strong>
        </p>
      </div>
    </div>
  </div>

  <script>
    const scales = {
      "C": ["C","D","E","F","G","A","B"],
      "G": ["G","A","B","C","D","E","F#"],
      "F": ["F","G","A","Bb","C","D","E"],
      "D": ["D","E","F#","G","A","B","C#"],
      "Bb":["Bb","C","D","Eb","F","G","A"]
    };
    const ACC_FONT = "22px system-ui";
    const ACC_X_OFFSET = 21;
    const ACC_Y_OFFSET = 7;
    const STORAGE_KEY = "sightplay_prefs_v2";
    const METER_MAX_RMS = 0.05;

    // OFFSETS DIAPAS√ìN
    const FRET_LEFT_COLUMN_WIDTH = 70;
    const FRET_CANVAS_LEFT_PAD   = 58;
    const FRET_CANVAS_RIGHT_PAD  = 15;
    const FRETBOARD_WIDTHS       = [520, 620, 740];
    let fretboardWidthIndex = 0;
    let fretboardWidth = FRETBOARD_WIDTHS[fretboardWidthIndex];

    const restImg = new Image();
    restImg.src = "silence_negra.png";
    let restImgLoaded = false;
    restImg.onload = () => {
      restImgLoaded = true;
      drawAllBars();
    };

    const RANGE_NOTES = [];
    (function buildRange() {
      const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
      for (let oct = 1; oct <= 7; oct++) {
        for (const n of names) {
          RANGE_NOTES.push(n + oct);
        }
      }
    })();

    function findRangeIndex(noteStr) {
      const idx = RANGE_NOTES.indexOf(noteStr);
      return idx === -1 ? 0 : idx;
    }

    let currentKey = "C";
    let currentClef = "treble";
    let currentInstrument = "piano";
    let currentMaxStep = 1;
    let currentBars = 1;
    let currentTimeSig = "4/4";
    let currentAlterDegree = 1;
    let currentAlterType = "none";
    let noiseGate = 0.01;
    let reverbLevel = 0.3;

    let currentMinRangeIdx = findRangeIndex("C3");
    let currentMaxRangeIdx = findRangeIndex("C6");

    let harmonyEnabled = false;
    let harmonyLocked = false;
    let harmonyDensity = 1.0;
    let harmonyTension = 0.0;
    let currentChords = [];

    let restProbability = 0.0;

    let currentMelody = [];
    let currentIndex = 0;

    let studySeconds = 0;
    let exercisesDone = 0;
    const IDLE_MS = 3000;
    let lastActiveTime = Date.now();

    let currentBpm = 115;
    let loopMode = false;

    // NUEVO: valores permitidos
    let allowedNoteValues = {
      q: true,   // negra
      qr: true,  // silencio de negra
      h: false,  // blanca
      hr: false  // silencio de blanca
    };

    const statusEl = document.getElementById("status");
    const progressEl = document.getElementById("progress");
    const studyInfoEl = document.getElementById("studyInfo");
    const staffCanvas = document.getElementById("staff");
    const ctx = staffCanvas.getContext("2d");
    const fretCanvas = document.getElementById("fretboard");
    const fretCtx = fretCanvas.getContext("2d");
    const fretboardBox = document.getElementById("fretboardBox");
    const fretTuners = document.getElementById("fretTuners");
    const fretWidthBtn = document.getElementById("fretWidthBtn");
    const muteBtn = document.getElementById("muteBtn");
    const playBtn = document.getElementById("playBtn");
    const prevBtn = document.getElementById("prevBtn");
    const startBtn = document.getElementById("startBtn");
    const loopBtn = document.getElementById("loopBtn");
    const bpmInput = document.getElementById("bpmInput");
    const toggleMenuBtn = document.getElementById("toggleMenuBtn");
    const toggleDonateBtn = document.getElementById("toggleDonateBtn");
    const selectorsGrid = document.getElementById("selectorsGrid");
    const donatePanel = document.getElementById("donatePanel");
    const gateSlider = document.getElementById("gateSlider");
    const gateVal = document.getElementById("gateVal");
    const reverbSlider = document.getElementById("reverbSlider");
    const reverbVal = document.getElementById("reverbVal");
    const meterCanvas = document.getElementById("meter");
    const meterCtx = meterCanvas.getContext("2d");
    const harmDensityInput = document.getElementById("harmDensity");
    const harmDensityVal = document.getElementById("harmDensityVal");
    const harmTensionInput = document.getElementById("harmTension");
    const harmTensionVal = document.getElementById("harmTensionVal");
    const minRangeSlider = document.getElementById("minRangeSlider");
    const maxRangeSlider = document.getElementById("maxRangeSlider");
    const minRangeLabel = document.getElementById("minRangeLabel");
    const maxRangeLabel = document.getElementById("maxRangeLabel");
    const minRangeDown = document.getElementById("minRangeDown");
    const minRangeUp = document.getElementById("minRangeUp");
    const maxRangeDown = document.getElementById("maxRangeDown");
    const maxRangeUp = document.getElementById("maxRangeUp");
    const restProb = document.getElementById("restProb");
    const restProbVal = document.getElementById("restProbVal");
    const harmLockBtn = document.getElementById("harmLockBtn");
    const noteValuesGroup = document.getElementById("noteValuesGroup");

    let advancing = false;
    let micEnabled = true;
    let isPlaying = false;
    let playbackAbort = false;
    let audioContext, analyser, dataArray;

    let reverbConvolver = null;
    let reverbGain = null;
    let reverbLowpass = null;

    let restAdvanceTimer = null;

    const clefImgs = { treble: new Image(), bass: new Image() };
    clefImgs.treble.src = "clef_treble.png";
    clefImgs.bass.src = "clef_bass.png";
    let trebleLoaded = false, bassLoaded = false;
    clefImgs.treble.onload = () => { trebleLoaded = true; drawAllBars(); };
    clefImgs.bass.onload = () => { bassLoaded = true; drawAllBars(); };

    const order = ["C","D","E","F","G","A","B"];
    const staffBottomY = 110;
    const lineSpacing = 10;
    const topLineY = staffBottomY - 4 * lineSpacing;
    const STAFF_LEFT = 20;
    const STAFF_CONTENT_START = 120;
    const BASE_CANVAS_HEIGHT = 160;

    const DEFAULT_GUITAR_TUNING = ["E5","B4","G4","D4","A3","E3"];
    let currentGuitarTuning = [...DEFAULT_GUITAR_TUNING];

    const TUNING_NOTES = [];
    (function buildTuningNotes() {
      const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
      for (let oct = 1; oct <= 5; oct++) {
        for (const n of names) {
          TUNING_NOTES.push(n + oct);
        }
      }
    })();

    const MAX_FRETS = 12;

    setInterval(() => {
      const now = Date.now();
      if (now - lastActiveTime <= IDLE_MS) {
        studySeconds++;
        updateStudyInfo();
      }
    }, 1000);

    function updateStudyInfo() {
      const mins = Math.floor(studySeconds / 60).toString().padStart(2,"0");
      const secs = (studySeconds % 60).toString().padStart(2,"0");
      studyInfoEl.textContent = `Tiempo de estudio: ${mins}:${secs} | Ejercicios completados: ${exercisesDone}`;
    }

    function saveSettings() {
      const data = {
        currentKey,
        currentClef,
        currentInstrument,
        currentMaxStep,
        currentBars,
        currentTimeSig,
        currentAlterDegree,
        currentAlterType,
        noiseGate,
        reverbLevel,
        harmonyEnabled,
        harmonyLocked,
        harmonyDensity,
        harmonyTension,
        currentMinRangeIdx,
        currentMaxRangeIdx,
        restProbability,
        currentBpm,
        loopMode,
        guitarTuning: currentGuitarTuning,
        fretboardWidthIndex,
        allowedNoteValues
      };
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch(e) {}
    }

    function updateFretboardVisibility() {
      if (currentInstrument === "guitar") {
        fretboardBox.style.display = "block";
        applyFretboardWidth();
      } else {
        fretboardBox.style.display = "none";
        fretCtx.clearRect(0,0,fretCanvas.width,fretCanvas.height);
      }
    }

    function applySettingsToUI(data) {
      function act(id, val) {
        const g = document.getElementById(id);
        if (!g) return;
        g.querySelectorAll(".opt-btn").forEach(b=>b.classList.remove("active"));
        const btn = g.querySelector(`.opt-btn[data-value="${val}"]`);
        if (btn) btn.classList.add("active");
      }
      act("instGroup", data.currentInstrument);
      act("barsGroup", String(data.currentBars));
      act("clefGroup", data.currentClef);
      act("tsGroup", data.currentTimeSig);
      act("keyGroup", data.currentKey);
      act("stepGroup", String(data.currentMaxStep));
      act("degGroup", data.currentAlterDegree);
      act("accTypeGroup", data.currentAlterType);
      act("harmGroup", data.harmonyEnabled ? "on" : "off");

      gateSlider.value = data.noiseGate ?? 0.01;
      noiseGate = parseFloat(gateSlider.value);
      gateVal.textContent = noiseGate.toFixed(3);

      if (data.reverbLevel !== undefined) {
        reverbLevel = data.reverbLevel;
        reverbSlider.value = reverbLevel;
        reverbVal.textContent = reverbLevel.toFixed(2);
      }

      if (data.harmonyDensity !== undefined) {
        harmonyDensity = data.harmonyDensity;
        harmDensityInput.value = harmonyDensity;
        harmDensityVal.textContent = harmonyDensity.toFixed(1);
      }

      if (data.harmonyTension !== undefined) {
        harmonyTension = data.harmonyTension;
        harmTensionInput.value = harmonyTension;
        harmTensionVal.textContent = harmonyTension.toFixed(1);
      }

      minRangeSlider.max = RANGE_NOTES.length - 1;
      maxRangeSlider.max = RANGE_NOTES.length - 1;

      currentMinRangeIdx = data.currentMinRangeIdx ?? currentMinRangeIdx;
      currentMaxRangeIdx = data.currentMaxRangeIdx ?? currentMaxRangeIdx;
      if (currentMinRangeIdx > currentMaxRangeIdx) currentMinRangeIdx = currentMaxRangeIdx;

      minRangeSlider.value = currentMinRangeIdx;
      maxRangeSlider.value = currentMaxRangeIdx;
      minRangeLabel.textContent = RANGE_NOTES[currentMinRangeIdx];
      maxRangeLabel.textContent = RANGE_NOTES[currentMaxRangeIdx];

      harmonyLocked = data.harmonyLocked ?? false;
      if (harmonyLocked) harmLockBtn.classList.add("active");
      else harmLockBtn.classList.remove("active");

      restProbability = data.restProbability ?? 0.0;
      restProb.value = restProbability;
      restProbVal.textContent = Math.round(restProbability * 100) + "%";

      currentBpm = data.currentBpm ?? 115;
      bpmInput.value = currentBpm;

      loopMode = data.loopMode ?? false;
      loopBtn.textContent = loopMode ? "Loop: on" : "Loop: off";

      currentGuitarTuning = data.guitarTuning ?? [...DEFAULT_GUITAR_TUNING];

      fretboardWidthIndex = data.fretboardWidthIndex ?? 0;
      if (fretboardWidthIndex < 0 || fretboardWidthIndex >= FRETBOARD_WIDTHS.length) {
        fretboardWidthIndex = 0;
      }
      fretboardWidth = FRETBOARD_WIDTHS[fretboardWidthIndex];

      // valores permitidos
      if (data.allowedNoteValues) {
        allowedNoteValues = data.allowedNoteValues;
      }
      if (noteValuesGroup) {
        noteValuesGroup.querySelectorAll(".opt-btn").forEach(btn => {
          const v = btn.dataset.value;
          if (allowedNoteValues[v]) btn.classList.add("active");
          else btn.classList.remove("active");
        });
      }

      updateFretboardVisibility();
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          applySettingsToUI({
            currentKey,
            currentClef,
            currentInstrument,
            currentMaxStep,
            currentBars,
            currentTimeSig,
            currentAlterDegree,
            currentAlterType,
            noiseGate,
            reverbLevel,
            harmonyEnabled,
            harmonyLocked,
            harmonyDensity,
            harmonyTension,
            currentMinRangeIdx,
            currentMaxRangeIdx,
            restProbability,
            currentBpm,
            loopMode,
            guitarTuning: currentGuitarTuning,
            fretboardWidthIndex,
            allowedNoteValues
          });
          return;
        }
        const data = JSON.parse(raw);
        currentKey = data.currentKey ?? currentKey;
        currentClef = data.currentClef ?? currentClef;
        currentInstrument = data.currentInstrument ?? currentInstrument;
        currentMaxStep = data.currentMaxStep ?? currentMaxStep;
        currentBars = data.currentBars ?? currentBars;
        currentTimeSig = data.currentTimeSig ?? currentTimeSig;
        currentAlterDegree = data.currentAlterDegree ?? currentAlterDegree;
        currentAlterType = data.currentAlterType ?? currentAlterType;
        noiseGate = data.noiseGate ?? noiseGate;
        reverbLevel = data.reverbLevel ?? reverbLevel;
        harmonyEnabled = data.harmonyEnabled ?? harmonyEnabled;
        harmonyLocked = data.harmonyLocked ?? harmonyLocked;
        harmonyDensity = data.harmonyDensity ?? harmonyDensity;
        harmonyTension = data.harmonyTension ?? harmonyTension;
        currentMinRangeIdx = data.currentMinRangeIdx ?? currentMinRangeIdx;
        currentMaxRangeIdx = data.currentMaxRangeIdx ?? currentMaxRangeIdx;
        restProbability = data.restProbability ?? restProbability;
        currentBpm = data.currentBpm ?? currentBpm;
        loopMode = data.loopMode ?? loopMode;
        currentGuitarTuning = data.guitarTuning ?? [...DEFAULT_GUITAR_TUNING];
        fretboardWidthIndex = data.fretboardWidthIndex ?? 0;
        if (fretboardWidthIndex < 0 || fretboardWidthIndex >= FRETBOARD_WIDTHS.length) {
          fretboardWidthIndex = 0;
        }
        fretboardWidth = FRETBOARD_WIDTHS[fretboardWidthIndex];
        allowedNoteValues = data.allowedNoteValues ?? allowedNoteValues;
        applySettingsToUI(data);
      } catch(e) {}
    }

    function createTuningSelectors() {
      if (!fretTuners) return;
      fretTuners.innerHTML = "";
      for (let i = 0; i < 6; i++) {
        const sel = document.createElement("select");
        sel.className = "string-tuner";
        sel.dataset.string = i;
        TUNING_NOTES.forEach(n => {
          const opt = document.createElement("option");
          opt.value = n;
          opt.textContent = n;
          sel.appendChild(opt);
        });
        sel.value = currentGuitarTuning[i] || DEFAULT_GUITAR_TUNING[i];
        sel.addEventListener("change", (e) => {
          const idx = parseInt(e.target.dataset.string, 10);
          currentGuitarTuning[idx] = e.target.value;
          saveSettings();
          drawFretboard(currentMelody[currentIndex] || null);
        });
        fretTuners.appendChild(sel);
      }
    }

    toggleMenuBtn.addEventListener("click", () => {
      const isHidden = selectorsGrid.classList.toggle("hidden");
      if (!isHidden) {
        donatePanel.classList.add("hidden");
      }
      lastActiveTime = Date.now();
      saveSettings();
    });

    toggleDonateBtn.addEventListener("click", () => {
      const isHidden = donatePanel.classList.toggle("hidden");
      if (!isHidden) {
        selectorsGrid.classList.add("hidden");
      }
    });

    // nota: botones de valores (multi toggle)
    if (noteValuesGroup) {
      noteValuesGroup.addEventListener("click", (e) => {
        if (!e.target.classList.contains("opt-btn")) return;
        const val = e.target.dataset.value;
        const newState = !allowedNoteValues[val];
        allowedNoteValues[val] = newState;
        if (newState) e.target.classList.add("active");
        else e.target.classList.remove("active");
        saveSettings();
        loadNewMelody();
      });
    }

    harmDensityInput.addEventListener("input", () => {
      harmonyDensity = parseFloat(harmDensityInput.value);
      harmDensityVal.textContent = harmonyDensity.toFixed(1);
      lastActiveTime = Date.now();
      saveSettings();
      if (harmonyEnabled && !harmonyLocked) {
        const hm = asHarmonyMelody(currentMelody);
        currentChords = generateHarmonyForMelody(hm);
        drawAllBars();
      }
    });

    harmTensionInput.addEventListener("input", () => {
      harmonyTension = parseFloat(harmTensionInput.value);
      harmTensionVal.textContent = harmonyTension.toFixed(1);
      lastActiveTime = Date.now();
      saveSettings();
      if (harmonyEnabled && !harmonyLocked) {
        const hm = asHarmonyMelody(currentMelody);
        currentChords = generateHarmonyForMelody(hm);
        drawAllBars();
      }
    });

    gateSlider.addEventListener("input", () => {
      noiseGate = parseFloat(gateSlider.value);
      gateVal.textContent = noiseGate.toFixed(3);
      lastActiveTime = Date.now();
      saveSettings();
    });

    reverbSlider.addEventListener("input", () => {
      reverbLevel = parseFloat(reverbSlider.value);
      reverbVal.textContent = reverbLevel.toFixed(2);
      if (reverbGain) reverbGain.gain.value = reverbLevel;
      lastActiveTime = Date.now();
      saveSettings();
    });

    restProb.addEventListener("input", () => {
      restProbability = parseFloat(restProb.value);
      restProbVal.textContent = Math.round(restProbability * 100) + "%";
      saveSettings();
    });

    harmLockBtn.addEventListener("click", () => {
      harmonyLocked = !harmonyLocked;
      if (harmonyLocked) harmLockBtn.classList.add("active");
      else {
        harmLockBtn.classList.remove("active");
        if (harmonyEnabled) {
          const hm = asHarmonyMelody(currentMelody);
          currentChords = generateHarmonyForMelody(hm);
          drawAllBars();
        }
      }
      saveSettings();
    });

    bpmInput.addEventListener("input", () => {
      const v = parseInt(bpmInput.value, 10);
      if (!isNaN(v)) {
        currentBpm = Math.min(220, Math.max(40, v));
        saveSettings();
      }
    });

    function updateRangeAndReload() {
      if (currentMinRangeIdx > currentMaxRangeIdx) {
        currentMinRangeIdx = currentMaxRangeIdx;
        minRangeSlider.value = currentMinRangeIdx;
      }
      minRangeLabel.textContent = RANGE_NOTES[currentMinRangeIdx];
      maxRangeLabel.textContent = RANGE_NOTES[currentMaxRangeIdx];
      saveSettings();
      loadNewMelody();
    }

    minRangeSlider.addEventListener("input", () => {
      currentMinRangeIdx = parseInt(minRangeSlider.value, 10);
      lastActiveTime = Date.now();
      updateRangeAndReload();
    });
    maxRangeSlider.addEventListener("input", () => {
      currentMaxRangeIdx = parseInt(maxRangeSlider.value, 10);
      lastActiveTime = Date.now();
      updateRangeAndReload();
    });
    minRangeDown.addEventListener("click", () => {
      if (currentMinRangeIdx > 0) {
        currentMinRangeIdx--;
        minRangeSlider.value = currentMinRangeIdx;
        updateRangeAndReload();
      }
    });
    minRangeUp.addEventListener("click", () => {
      if (currentMinRangeIdx < currentMaxRangeIdx) {
        currentMinRangeIdx++;
        minRangeSlider.value = currentMinRangeIdx;
        updateRangeAndReload();
      }
    });
    maxRangeDown.addEventListener("click", () => {
      if (currentMaxRangeIdx > currentMinRangeIdx) {
        currentMaxRangeIdx--;
        maxRangeSlider.value = currentMaxRangeIdx;
        updateRangeAndReload();
      }
    });
    maxRangeUp.addEventListener("click", () => {
      if (currentMaxRangeIdx < RANGE_NOTES.length - 1) {
        currentMaxRangeIdx++;
        maxRangeSlider.value = currentMaxRangeIdx;
        updateRangeAndReload();
      }
    });

    function attachGroup(id, cb) {
      const g = document.getElementById(id);
      g.addEventListener("click", e => {
        if (!e.target.classList.contains("opt-btn")) return;
        g.querySelectorAll(".opt-btn").forEach(b=>b.classList.remove("active"));
        e.target.classList.add("active");
        cb(e.target.dataset.value);
        lastActiveTime = Date.now();
        saveSettings();
      });
    }

    attachGroup("instGroup", v => {
      currentInstrument = v;
      updateFretboardVisibility();
      loadNewMelody();
    });
    attachGroup("barsGroup", v => { currentBars = parseInt(v,10); loadNewMelody(); });
    attachGroup("clefGroup", v => { currentClef = v; loadNewMelody(); });
    attachGroup("tsGroup", v => { currentTimeSig = v; loadNewMelody(); });
    attachGroup("keyGroup", v => { currentKey = v; loadNewMelody(); });
    attachGroup("stepGroup", v => { currentMaxStep = parseInt(v,10); loadNewMelody(); });
    attachGroup("degGroup", v => { currentAlterDegree = parseInt(v,10); loadNewMelody(); });
    attachGroup("accTypeGroup", v => { currentAlterType = v; loadNewMelody(); });
    attachGroup("harmGroup", v => {
      harmonyEnabled = (v === "on");
      if (harmonyEnabled) {
        if (!harmonyLocked || !currentChords.length) {
          const hm = asHarmonyMelody(currentMelody);
          currentChords = generateHarmonyForMelody(hm);
        }
      } else {
        currentChords = [];
      }
      drawAllBars();
    });

    function resizeCanvasForBars(bars, minHeight = BASE_CANVAS_HEIGHT) {
      const base = 520;
      const extraPerBar = 140;
      const newW = base + (bars - 1) * extraPerBar;
      const h = Math.max(minHeight, staffCanvas.height || BASE_CANVAS_HEIGHT);
      staffCanvas.width = newW;
      staffCanvas.height = h;
    }

    function noteStrToDiatonic(n) {
      const m = n && typeof n === "string" ? n.match(/^([A-G])([#b]?)(\d)$/) : null;
      if (!m) return null;
      const letter = m[1];
      const oct = parseInt(m[3], 10);
      return oct * 7 + order.indexOf(letter);
    }

    function getAllowedRange() {
      const minNoteStr = RANGE_NOTES[currentMinRangeIdx];
      const maxNoteStr = RANGE_NOTES[currentMaxRangeIdx];
      let minDia = noteStrToDiatonic(minNoteStr);
      let maxDia = noteStrToDiatonic(maxNoteStr);
      if (minDia === null) minDia = 0;
      if (maxDia === null) maxDia = 999;
      return {minDia, maxDia};
    }

    function getCurrentScale() { return scales[currentKey] || scales["C"]; }

    function keyAccidentalForLetter(key, letter) {
      const scale = getCurrentScale();
      for (const deg of scale) {
        if (deg[0] === letter) {
          if (deg.includes("#")) return "#";
          if (deg.includes("b")) return "b";
          return "";
        }
      }
      return "";
    }

    function buildAvailableNotes(scale, minDia, maxDia) {
      const notes = [];
      for (let oct = 1; oct <= 7; oct++) {
        for (const name of scale) {
          const baseLetter = name.replace(/[#b]/,"");
          const dia = oct * 7 + order.indexOf(baseLetter);
          if (dia >= minDia && dia <= maxDia) {
            notes.push(name + oct);
          }
        }
      }
      notes.sort((a,b) => noteStrToDiatonic(a) - noteStrToDiatonic(b));
      return notes;
    }

    // helper para escoger siguiente nota diat√≥nica con preferencia a conjunto
    function pickNextPitchIndex(prevIndex, available, maxStep, minDia, maxDia) {
      const minIdx = Math.max(prevIndex - maxStep, 0);
      const maxIdx = Math.min(prevIndex + maxStep, available.length - 1);
      const candidates = [];
      for (let d = 1; d <= maxStep; d++) {
        if (prevIndex - d >= minIdx) candidates.push({ idx: prevIndex - d, interval: d });
        if (prevIndex + d <= maxIdx) candidates.push({ idx: prevIndex + d, interval: d });
      }
      let candidateIdx = prevIndex;
      if (candidates.length) {
        const stepCands = candidates.filter(c => c.interval === 1);
        const otherCands = candidates.filter(c => c.interval > 1);
        const STEP_DOMINANCE = 0.6;
        let chosen = null;
        const r = Math.random();
        if (stepCands.length && (r < STEP_DOMINANCE || !otherCands.length)) {
          chosen = stepCands[Math.floor(Math.random() * stepCands.length)];
        } else if (otherCands.length) {
          let totalW = 0;
          for (const c of otherCands) totalW += 1 / c.interval;
          let pick = Math.random() * totalW;
          for (const c of otherCands) {
            const w = 1 / c.interval;
            if (pick < w) { chosen = c; break; }
            pick -= w;
          }
          if (!chosen) chosen = otherCands[otherCands.length - 1];
        }
        if (chosen) candidateIdx = chosen.idx;
      }
      const candDia = noteStrToDiatonic(available[candidateIdx]);
      if (candDia < minDia || candDia > maxDia) {
        candidateIdx = prevIndex;
      }
      return candidateIdx;
    }

    // GENERADOR con soporte de negras/blancas + modo solo blancas
    function generateMelody(maxStep) {
      const {minDia, maxDia} = getAllowedRange();
      const beatsPerBar = currentTimeSig === "3/4" ? 3 : 4;
      const totalBeats = currentBars * beatsPerBar;
      const available = buildAvailableNotes(getCurrentScale(), minDia, maxDia);
      if (!available.length) return [];

      let startIndex;
      {
        const midLow = Math.floor(available.length * 0.3);
        const midHigh = Math.floor(available.length * 0.7);
        startIndex = midLow + Math.floor(Math.random() * Math.max(1, midHigh - midLow + 1));
        if (startIndex > available.length - 1) startIndex = available.length - 1;
      }

      // modo SOLO blancas: negras apagadas, blancas encendidas
      if (!allowedNoteValues.q && allowedNoteValues.h) {
        const melody = new Array(totalBeats).fill(null);
        let prevIndex = startIndex;
        for (let bar = 0; bar < currentBars; bar++) {
          const barStart = bar * beatsPerBar;
          const wantRest1 = allowedNoteValues.hr && Math.random() < restProbability;
          if (wantRest1) {
            melody[barStart] = { t: "hr" };
          } else {
            const candIdx = pickNextPitchIndex(prevIndex, available, maxStep, minDia, maxDia);
            melody[barStart] = { t: "hn", note: available[candIdx] };
            prevIndex = candIdx;
          }
          melody[barStart + 1] = { t: "cont" };

          const remaining = beatsPerBar - 2;
          if (remaining >= 2) {
            const pos = barStart + 2;
            const wantRest2 = allowedNoteValues.hr && Math.random() < restProbability;
            if (wantRest2) {
              melody[pos] = { t: "hr" };
            } else {
              const candIdx2 = pickNextPitchIndex(prevIndex, available, maxStep, minDia, maxDia);
              melody[pos] = { t: "hn", note: available[candIdx2] };
              prevIndex = candIdx2;
            }
            melody[pos + 1] = { t: "cont" };
          } else if (remaining === 1) {
            melody[barStart + 2] = allowedNoteValues.qr ? "R" : (available[prevIndex] || "R");
          }
        }
        return melody;
      }

      // modo normal con negras
      const melody = new Array(totalBeats).fill(null);
      let prevIndex = startIndex;
      for (let beat = 0; beat < totalBeats; beat++) {
        if (melody[beat] !== null) continue;

        const posInBar = beat % beatsPerBar;
        const beatsLeft = beatsPerBar - posInBar;
        const canHalf = allowedNoteValues.h && beatsLeft >= 2;
        const wantRest = Math.random() < restProbability;

        // intentamos blanca
        if (canHalf && Math.random() < 0.25) {
          if (wantRest && allowedNoteValues.hr) {
            melody[beat] = { t: "hr" };
          } else {
            const candIdx = pickNextPitchIndex(prevIndex, available, maxStep, minDia, maxDia);
            melody[beat] = { t: "hn", note: available[candIdx] };
            prevIndex = candIdx;
          }
          melody[beat + 1] = { t: "cont" };
          continue;
        }

        // negra / silencio de negra
        if (wantRest && allowedNoteValues.qr) {
          melody[beat] = "R";
        } else if (allowedNoteValues.q) {
          const candIdx = pickNextPitchIndex(prevIndex, available, maxStep, minDia, maxDia);
          melody[beat] = available[candIdx];
          prevIndex = candIdx;
        } else {
          // si no hay negra permitida, cae en blanco m√≠nimo
          melody[beat] = "R";
        }
      }

      return melody;
    }

    // fusi√≥n de dos silencios de negra en uno de blanca
    function mergeQuarterRestsToHalf(melody) {
      const beatsPerBar = currentTimeSig === "3/4" ? 3 : 4;
      for (let i = 0; i < melody.length - 1; i++) {
        const posInBar = i % beatsPerBar;
        if (posInBar < beatsPerBar - 1) {
          if (melody[i] === "R" && melody[i+1] === "R") {
            melody[i] = { t: "hr" };
            melody[i+1] = { t: "cont" };
          }
        }
      }
      return melody;
    }

    function applyAccidentalsToMelody(melody) {
      if (currentAlterType === "none") return melody;
      const scale = getCurrentScale();
      const degIndex = currentAlterDegree - 1;
      const baseDegName = scale[degIndex];
      const baseLetter = baseDegName[0];
      const baseKeyAcc = baseDegName.includes("#") ? "#" : (baseDegName.includes("b") ? "b" : "");

      return melody.map(n => {
        if (!n) return n;
        if (typeof n === "object") {
          if (n.t === "hn" && n.note) {
            const modified = applyAccidentalsToMelody([n.note])[0];
            return { ...n, note: modified };
          }
          return n;
        }
        if (n === "R") return n;
        const m = n.match(/^([A-G])([#b]?)(\d)$/);
        if (!m) return n;
        const letter = m[1];
        const acc = m[2] || "";
        const oct = m[3];
        if (letter !== baseLetter) return n;

        if (currentAlterType === "flat" && baseKeyAcc === "#") {
          return letter + oct;
        }

        if (Math.random() < 0.5) return n;

        if (currentAlterType === "sharp") {
          if (acc === "#") return n;
          return letter + "#" + oct;
        } else if (currentAlterType === "flat") {
          if (acc === "b") return n;
          return letter + "b" + oct;
        }
        return n;
      });
    }

    // --- armon√≠a, igual que antes ---
    const NOTE_TO_SEMITONE = {
      "C":0, "C#":1, "Db":1, "D":2, "D#":3, "Eb":3, "E":4,
      "F":5, "F#":6, "Gb":6, "G":7, "G#":8, "Ab":8, "A":9,
      "A#":10, "Bb":10, "B":11
    };

    function nameToSemitone(name) {
      if (name === "Cb") return 11;
      if (name === "Fb") return 4;
      if (name === "E#") return 5;
      if (name === "B#") return 0;
      return NOTE_TO_SEMITONE[name];
    }

    function baseName(n) {
      const m = n && typeof n === "string" ? n.match(/^([A-G][#b]?)/) : null;
      return m ? m[1] : n;
    }

    function parseNoteParts(noteStr) {
      const m = noteStr && typeof noteStr === "string" ? noteStr.match(/^([A-G])([#b]?)(\d)$/) : null;
      if (!m) return null;
      return { letter: m[1], acc: m[2] || "", oct: parseInt(m[3],10) };
    }

    function isUserAlteredMelodyNote(noteStr) {
      if (noteStr === "R") return false;
      if (currentAlterType === "none") return false;
      const parts = parseNoteParts(noteStr);
      if (!parts) return false;
      const scale = getCurrentScale();
      const degIdx = currentAlterDegree - 1;
      const baseDegName = scale[degIdx];
      const baseLetter = baseDegName[0];
      const baseKeyAcc = baseDegName.includes("#") ? "#" : (baseDegName.includes("b") ? "b" : "");

      if (parts.letter !== baseLetter) return false;

      if (currentAlterType === "sharp") {
        return parts.acc === "#" || (parts.acc === "" && baseKeyAcc !== "#");
      } else if (currentAlterType === "flat") {
        if (baseKeyAcc === "#") {
          return (parts.acc === "" || parts.acc === "b");
        } else {
          return parts.acc === "b";
        }
      }
      return false;
    }

    function buildModalChordFromUserAlter(noteStr) {
      const parts = parseNoteParts(noteStr);
      if (!parts) return null;
      const scale = getCurrentScale();
      const degIdx = currentAlterDegree - 1;
      const diatThird = scale[(degIdx + 2) % 7];
      const diatFifth = scale[(degIdx + 4) % 7];
      const rootName = parts.letter + (parts.acc || "");
      const chordTones = [rootName, diatThird, diatFifth];

      const rootSem = nameToSemitone(rootName);
      const thirdSem = nameToSemitone(diatThird);
      const fifthSem = nameToSemitone(diatFifth);
      let symbol = rootName;
      let playbackRoot = rootName;

      if (rootSem != null && thirdSem != null && fifthSem != null) {
        const int3 = (thirdSem - rootSem + 12) % 12;
        const int5 = (fifthSem - rootSem + 12) % 12;
        if (int3 === 3 && int5 === 6) {
          symbol = rootName + "dim";
        } else if (int3 === 3 && int5 === 7) {
          symbol = rootName + "m";
        } else if (int3 === 4 && int5 === 7) {
          symbol = rootName;
        } else if (int3 === 4 && int5 === 8) {
          if (Math.random() < 0.5) {
            symbol = rootName + "+";
          } else {
            symbol = diatThird + "+";
            playbackRoot = diatThird;
          }
        }
      }

      const melodyBase = baseName(noteStr);
      if (melodyBase !== playbackRoot && chordTones.some(t => baseName(t) === melodyBase)) {
        symbol = symbol + "/" + melodyBase;
      }

      return {
        root: playbackRoot,
        tones: chordTones,
        symbol
      };
    }

    function buildDiatonicChordsForKey(key) {
      const scale = getCurrentScale();
      const chords = [];
      for (let i = 0; i < 7; i++) {
        const root = scale[i];
        const third = scale[(i+2)%7];
        const fifth = scale[(i+4)%7];
        const seventh = scale[(i+6)%7];

        let symbol = root;
        let tones = [root, third, fifth, seventh];

        if (i === 0) {
          symbol = root + "maj7";
        } else if (i === 1) {
          symbol = root + "m7";
        } else if (i === 2) {
          symbol = root + "m7";
        } else if (i === 3) {
          symbol = root + "maj7";
        } else if (i === 4) {
          symbol = root + "7";
        } else if (i === 5) {
          symbol = root + "m7";
        } else if (i === 6) {
          symbol = root + "m7‚ô≠5";
        }

        chords.push({
          root,
          tones,
          symbol,
          index: i
        });
      }
      return chords;
    }

    function tensionFromInterval(semDiff) {
      if (semDiff === 1) return "‚ô≠9";
      if (semDiff === 2) return "9";
      if (semDiff === 5) return "11";
      if (semDiff === 6) return "#11";
      if (semDiff === 9) return "13";
      return null;
    }

    function addTensionToSymbol(symbol, tension) {
      if (!tension) return symbol;
      if (symbol.includes("(" + tension + ")")) return symbol;
      return symbol + " (" + tension + ")";
    }

    function chooseChordForNote(note, posInBar, prevChordIdx, chords) {
      const bn = baseName(note);
      const sem = nameToSemitone(bn);
      if (sem === undefined) return { chosen: null, idx: prevChordIdx };

      const strictCandidates = [];
      const looseCandidates = [];
      chords.forEach(ch => {
        const has = ch.tones.some(t => nameToSemitone(baseName(t)) === sem);
        if (has) strictCandidates.push(ch);
        else looseCandidates.push(ch);
      });

      let pool = [];
      if (strictCandidates.length) {
        if (harmonyTension <= 0.05) {
          pool = strictCandidates;
        } else {
          const r = Math.random();
          if (r < 1 - harmonyTension) {
            pool = strictCandidates;
          } else {
            pool = looseCandidates.length ? looseCandidates : strictCandidates;
          }
        }
      } else {
        pool = looseCandidates.length ? looseCandidates : chords;
      }

      const nonRepeat = pool.filter(ch => ch.index !== prevChordIdx);
      const finalPool = nonRepeat.length ? nonRepeat : pool;
      const chosen = finalPool[Math.floor(Math.random() * finalPool.length)];
      return { chosen, idx: chosen.index, noteSem: sem };
    }

    function generateHarmonyForMelody(melody) {
      if (!melody || !melody.length) return [];
      const chords = buildDiatonicChordsForKey(currentKey);
      const result = [];
      let lastChordIdx = -1;
      const notesPerBar = currentTimeSig === "3/4" ? 3 : 4;

      for (let i = 0; i < melody.length; i++) {
        const note = melody[i];
        const posInBar = i % notesPerBar;
        const midPos = (notesPerBar === 4) ? 2 : 2;
        const isStrong = posInBar === 0;
        const isMid = posInBar === midPos;

        if (note === "R") {
          result.push(null);
          continue;
        }

        if (isUserAlteredMelodyNote(note)) {
          const modalChord = buildModalChordFromUserAlter(note);
          if (modalChord) {
            result.push(modalChord);
            lastChordIdx = -1;
            continue;
          }
        }

        let skip = false;
        if (harmonyDensity < 0.35) {
          if (!isStrong) skip = true;
        } else if (harmonyDensity >= 0.35 && harmonyDensity < 0.7) {
          if (!isStrong && !isMid) skip = true;
        } else {
          if (Math.random() > harmonyDensity) skip = true;
        }

        if (skip) {
          result.push(null);
          continue;
        }

        const { chosen, idx, noteSem } = chooseChordForNote(note, posInBar, lastChordIdx, chords);
        if (!chosen) {
          result.push(null);
        } else {
          const rootSem = nameToSemitone(baseName(chosen.root));
          let tensionName = null;
          if (noteSem !== undefined && rootSem !== undefined) {
            const diff = (noteSem - rootSem + 12) % 12;
            tensionName = tensionFromInterval(diff);
          }
          const symWithTension = tensionName ? addTensionToSymbol(chosen.symbol, tensionName) : chosen.symbol;
          result.push({
            ...chosen,
            symbol: symWithTension
          });
          lastChordIdx = idx;
        }
      }

      // asegurar un acorde al inicio de cada comp√°s
      const totalBars = currentBars;
      for (let b = 0; b < totalBars; b++) {
        const start = b * notesPerBar;
        const end = Math.min(start + notesPerBar, melody.length);
        const hasChord = result.slice(start, end).some(x => x);
        if (!hasChord) {
          const note = melody[start];
          if (note === "R") continue;
          if (isUserAlteredMelodyNote(note)) {
            const modalChord = buildModalChordFromUserAlter(note);
            if (modalChord) {
              result[start] = modalChord;
              continue;
            }
          }
          const { chosen, idx, noteSem } = chooseChordForNote(note, 0, -1, chords);
          if (chosen) {
            const rootSem = nameToSemitone(baseName(chosen.root));
            let tensionName = null;
            if (noteSem !== undefined && rootSem !== undefined) {
              const diff = (noteSem - rootSem + 12) % 12;
              tensionName = tensionFromInterval(diff);
            }
            const symWithTension = tensionName ? addTensionToSymbol(chosen.symbol, tensionName) : chosen.symbol;
            result[start] = { ...chosen, symbol: symWithTension };
          }
        }
      }

      return result;
    }

    // convierte arreglo con objetos a uno solo de nombres/rest para armon√≠a
    function asHarmonyMelody(mel) {
      return mel.map(entry => {
        if (!entry) return "R";
        if (typeof entry === "string") {
          return entry;
        }
        if (entry.t === "hn") return entry.note;
        if (entry.t === "hr") return "R";
        if (entry.t === "cont") return "R";
        return "R";
      });
    }

    function generateMelodyFromLockedHarmony(chordsArr) {
      const {minDia, maxDia} = getAllowedRange();
      const notesPerBar = currentTimeSig === "3/4" ? 3 : 4;
      const totalNeeded = currentBars * notesPerBar;
      if (!chordsArr || !chordsArr.length || chordsArr.length !== totalNeeded) {
        return null;
      }

      const melody = [];
      let prevDia = null;

      for (let i = 0; i < chordsArr.length; i++) {
        const ch = chordsArr[i];
        if (!ch) {
          const normalMelody = generateMelody(currentMaxStep);
          return normalMelody;
        }

        const toneBases = ch.tones.map(t => baseName(t));
        const candidates = [];
        for (let oct = 1; oct <= 7; oct++) {
          for (const tb of toneBases) {
            const nn = tb + oct;
            const dia = noteStrToDiatonic(nn);
            if (dia !== null && dia >= minDia && dia <= maxDia) {
              candidates.push({note: nn, dia});
            }
          }
        }
        if (!candidates.length) {
          const normalMelody = generateMelody(currentMaxStep);
          return normalMelody;
        }

        let chosen;
        if (prevDia === null) {
          chosen = candidates[Math.floor(candidates.length / 2)];
        } else {
          candidates.sort((a,b) => Math.abs(a.dia - prevDia) - Math.abs(b.dia - prevDia));
          chosen = candidates[0];
          const maxJump = currentMaxStep;
          if (Math.abs(chosen.dia - prevDia) > maxJump) {
            const alt = candidates.find(c => Math.abs(c.dia - prevDia) <= maxJump);
            if (alt) chosen = alt;
          }
        }

        melody.push(chosen.note);
        prevDia = chosen.dia;
      }

      return melody;
    }

    function loadNewMelody() {
      if (restAdvanceTimer) {
        clearTimeout(restAdvanceTimer);
        restAdvanceTimer = null;
      }

      resizeCanvasForBars(currentBars);
      const notesPerBar = currentTimeSig === "3/4" ? 3 : 4;
      let melody;
      if (harmonyEnabled && harmonyLocked && currentChords.length === currentBars * notesPerBar) {
        melody = generateMelodyFromLockedHarmony(currentChords);
      } else {
        melody = generateMelody(currentMaxStep);
        melody = applyAccidentalsToMelody(melody);
        melody = mergeQuarterRestsToHalf(melody);
      }

      currentMelody = melody;
      currentIndex = 0;
      lastActiveTime = Date.now();
      updateProgress();

      if (harmonyEnabled) {
        if (harmonyLocked && currentChords.length) {
          // mantener armon√≠a
        } else {
          const hm = asHarmonyMelody(currentMelody);
          currentChords = generateHarmonyForMelody(hm);
        }
      } else {
        currentChords = [];
      }

      drawAllBars();
      updateStatusForCurrent();
    }

    function noteToY(noteStr) {
      if (noteStr === "R") return staffBottomY;
      const m = noteStr && typeof noteStr === "string" ? noteStr.match(/^([A-G])([b#]?)(\d)$/) : null;
      if (!m) return staffBottomY;
      const letter = m[1];
      const oct = parseInt(m[3], 10);
      const baseDiatonic = (currentClef === "treble")
        ? (4 * 7 + order.indexOf("E"))
        : (2 * 7 + order.indexOf("G"));
      const diatonicNum = oct * 7 + order.indexOf(letter);
      const diff = diatonicNum - baseDiatonic;
      return staffBottomY - diff * 5;
    }

    function drawStaffLines() {
      ctx.clearRect(0,0,staffCanvas.width,staffCanvas.height);
      ctx.strokeStyle = "#e2e8f0";
      ctx.lineWidth = 1;
      for (let i = 0; i < 5; i++) {
        const y = staffBottomY - i * lineSpacing;
        ctx.beginPath();
        ctx.moveTo(STAFF_LEFT, y);
        ctx.lineTo(staffCanvas.width - 20, y);
        ctx.stroke();
      }
      drawClef();
      drawKeySignature(currentKey);
      drawTimeSignature();
    }

    function drawTimeSignature() {
      const x = 90;
      const centerY = (topLineY + staffBottomY) / 2;
      const numY = centerY - 4;
      const denY = centerY + 18;
      ctx.fillStyle = "#e2e8f0";
      ctx.font = "20px system-ui";
      if (currentTimeSig === "3/4") {
        ctx.fillText("3", x, numY);
        ctx.fillText("4", x, denY);
      } else {
        ctx.fillText("4", x, numY);
        ctx.fillText("4", x, denY);
      }
    }

    function drawClef() {
      if (currentClef === "treble") {
        if (clefImgs.treble.complete) {
          ctx.drawImage(clefImgs.treble, 20, 125 - 80, 40, 90);
        } else {
          const x = 32;
          ctx.strokeStyle = "#e2e8f0";
          ctx.lineWidth = 1.4;
          ctx.beginPath();
          ctx.moveTo(x, staffBottomY - 50);
          ctx.lineTo(x, staffBottomY + 25);
          ctx.stroke();
        }
      } else {
        if (clefImgs.bass.complete) {
          ctx.drawImage(clefImgs.bass, 30, 124 - 55, 30, 40);
        } else {
          const x = 30;
          const y = staffBottomY - 25;
          ctx.strokeStyle = "#e2e8f0";
          ctx.lineWidth = 1.4;
          ctx.beginPath();
          ctx.arc(x, y, 12, 0.4 * Math.PI, 1.4 * Math.PI, false);
          ctx.stroke();
        }
      }
    }

    function drawAccidental(sym, x, y) {
      ctx.font = ACC_FONT;
      ctx.fillStyle = "#e2e8f0";
      ctx.fillText(sym, x, y + ACC_Y_OFFSET);
    }

    function drawKeySignature(key) {
      const clef = currentClef;
      let x = 55;

      if (clef === "treble") {
        if (key === "G") {
          drawAccidental("#", x, noteToY("F5"));
        } else if (key === "D") {
          drawAccidental("#", x, noteToY("F5"));
          drawAccidental("#", x + 15, noteToY("C5"));
        } else if (key === "F") {
          drawAccidental("‚ô≠", x, noteToY("B4"));
        } else if (key === "Bb") {
          drawAccidental("‚ô≠", x, noteToY("B4"));
          drawAccidental("‚ô≠", x + 15, noteToY("E5"));
        }
      } else {
        if (key === "G") {
          drawAccidental("#", x, noteToY("F3"));
        } else if (key === "D") {
          drawAccidental("#", x, noteToY("F3"));
          drawAccidental("#", x + 15, noteToY("C4"));
        } else if (key === "F") {
          drawAccidental("‚ô≠", x, noteToY("B2"));
        } else if (key === "Bb") {
          drawAccidental("‚ô≠", x, noteToY("B2"));
          drawAccidental("‚ô≠", x + 15, noteToY("E3"));
        }
      }
    }

    function drawLedgerLinesForY(x, y) {
      if (y < topLineY) {
        let count = 0;
        for (let ly = topLineY - 10; ly >= y && count < 12; ly -= 10, count++) {
          ctx.beginPath();
          ctx.moveTo(x - 15, ly);
          ctx.lineTo(x + 15, ly);
          ctx.strokeStyle = "#e2e8f0";
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
      if (y > staffBottomY) {
        let count = 0;
        for (let ly = staffBottomY + 10; ly <= y && count < 12; ly += 10, count++) {
          ctx.beginPath();
          ctx.moveTo(x - 15, ly);
          ctx.lineTo(x + 15, ly);
          ctx.strokeStyle = "#e2e8f0";
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
    }

    function drawQuarterRest(x) {
      const baseY = topLineY + 20;
      if (restImgLoaded) {
        const w = 10;
        const h = 30;
        ctx.drawImage(restImg, x - w/2, baseY - h/2, w, h);
        return;
      }
      ctx.strokeStyle = "#e2e8f0";
      ctx.fillStyle = "#e2e8f0";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(x, baseY - 10);
      ctx.lineTo(x - 6, baseY);
      ctx.lineTo(x, baseY + 10);
      ctx.lineTo(x - 6, baseY + 20);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x - 6, baseY - 2, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x - 6, baseY + 18, 2.5, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawHalfRest(x) {
      const y = topLineY + 10; // sobre la l√≠nea 3 en clave de sol
      const w = 14;
      const h = 5;
      ctx.fillStyle = "#e2e8f0";
      ctx.fillRect(x - w/2, y - h/2, w, h);
    }

    function drawNoteHead(x, y, color) {
      if (color === undefined) color = "#e2e8f0";
      drawLedgerLinesForY(x, y);
      ctx.beginPath();
      ctx.ellipse(x, y, 7, 5, -0.3, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      const stemRefY = currentClef === "treble" ? noteToY("B4") : noteToY("D3");
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 1.5;
      if (y < stemRefY) {
        ctx.moveTo(x - 6, y);
        ctx.lineTo(x - 6, y + 30);
      } else {
        ctx.moveTo(x + 6, y);
        ctx.lineTo(x + 6, y - 30);
      }
      ctx.stroke();
    }

    function drawHalfNote(x, y, color) {
      if (color === undefined) color = "#e2e8f0";
      drawLedgerLinesForY(x, y);
      ctx.beginPath();
      ctx.ellipse(x, y, 7, 5, -0.3, 0, Math.PI * 2);
      ctx.strokeStyle = color;
      ctx.lineWidth = 1.4;
      ctx.stroke();
      const stemRefY = currentClef === "treble" ? noteToY("B4") : noteToY("D3");
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 1.5;
      if (y < stemRefY) {
        ctx.moveTo(x - 6, y);
        ctx.lineTo(x - 6, y + 35);
      } else {
        ctx.moveTo(x + 6, y);
        ctx.lineTo(x + 6, y - 35);
      }
      ctx.stroke();
    }

    function drawAllBars(activeOverrideIdx = null, triangleOverrideIdx = null) {
      const rightLimit = staffCanvas.width - 20;
      const availableWidth = rightLimit - STAFF_CONTENT_START;
      const barWidth = availableWidth / currentBars;
      const innerPadding = 14;
      const beatsPerBar = currentTimeSig === "3/4" ? 3 : 4;
      const noteArea = barWidth - innerPadding * 2;
      const noteStep = noteArea / beatsPerBar;

      const positions = [];
      let maxNoteY = staffBottomY;

      const barAccidentals = Array.from({length: currentBars}, () => ({}));

      for (let i = 0; i < currentMelody.length; i++) {
        const barIndex = Math.floor(i / beatsPerBar);
        const posInBar = i % beatsPerBar;
        const barLeft = STAFF_CONTENT_START + barIndex * barWidth;
        const x = barLeft + innerPadding + noteStep * posInBar + noteStep * 0.3;
        const entry = currentMelody[i];
        let noteStr = null;
        let y = staffBottomY;
        let isRestQ = false;
        let isRestH = false;
        let accidentalSymbol = null;
        let isCont = false;

        if (typeof entry === "string") {
          if (entry === "R") {
            isRestQ = true;
            y = staffBottomY;
          } else {
            noteStr = entry;
            y = noteToY(noteStr);
          }
        } else if (entry && typeof entry === "object") {
          if (entry.t === "hn") {
            noteStr = entry.note;
            y = noteToY(noteStr);
          } else if (entry.t === "hr") {
            isRestH = true;
            y = staffBottomY;
          } else if (entry.t === "cont") {
            isCont = true;
          }
        }

        if (y > maxNoteY) maxNoteY = y;

        if (noteStr) {
          const m = noteStr.match(/^([A-G])([#b]?)(\d)$/);
          if (m) {
            const letter = m[1];
            const noteAcc = m[2] || "";
            const keyAcc = keyAccidentalForLetter(currentKey, letter);
            const barMap = barAccidentals[barIndex];
            const prevOffset = (barMap[letter] !== undefined)
              ? barMap[letter]
              : (keyAcc === "#" ? 1 : (keyAcc === "b" ? -1 : 0));
            const noteOffset = noteAcc === "#" ? 1 : (noteAcc === "b" ? -1 : 0);

            if (noteOffset !== prevOffset) {
              if (noteOffset === 0 && (keyAcc === "#" || keyAcc === "b")) {
                accidentalSymbol = "‚ôÆ";
              } else if (noteOffset === 1) {
                accidentalSymbol = "#";
              } else if (noteOffset === -1) {
                accidentalSymbol = "‚ô≠";
              } else {
                accidentalSymbol = "‚ôÆ";
              }
            }

            barMap[letter] = noteOffset;
          }
        }

        let state = "normal";
        const realActive = (activeOverrideIdx !== null) ? activeOverrideIdx : currentIndex;
        if (i < realActive) state = "done";
        else if (i === realActive) state = "active";

        positions.push({x, y, state, accidentalSymbol, noteStr, isRestQ, isRestH, isCont});
      }

      const baseTriY = staffBottomY + 20;
      let triangleY = baseTriY;
      if (maxNoteY + 20 > triangleY) triangleY = maxNoteY + 20;
      const neededHeight = triangleY + 20;
      if (staffCanvas.height < neededHeight) {
        const w = staffCanvas.width;
        staffCanvas.height = neededHeight;
        staffCanvas.width = w;
      } else if (staffCanvas.height > neededHeight && neededHeight < BASE_CANVAS_HEIGHT) {
        const w = staffCanvas.width;
        staffCanvas.height = BASE_CANVAS_HEIGHT;
        staffCanvas.width = w;
      }

      drawStaffLines();

      for (let i = 0; i < positions.length; i++) {
        const {x, y, state, accidentalSymbol, noteStr, isRestQ, isRestH, isCont} = positions[i];
        let color = "#e2e8f0";
        if (state === "done") color = "#22c55e";
        else if (state === "active") color = "#eab308";

        if (isCont) {
          // no dibujamos nada
        } else if (isRestQ) {
          drawQuarterRest(x, y);
        } else if (isRestH) {
          drawHalfRest(x);
        } else if (noteStr) {
          if (accidentalSymbol) {
            drawAccidental(accidentalSymbol, x - ACC_X_OFFSET, y);
          }
          // si esta posici√≥n corresponde a mitad de una blanca (t:cont) ya no estamos aqu√≠
          // as√≠ que s√≥lo dibujamos
          // si el entry original era "hn" ‚Üí lo detectamos por buscar en currentMelody
          const entry = currentMelody[i];
          if (entry && typeof entry === "object" && entry.t === "hn") {
            drawHalfNote(x, y, color);
          } else {
            drawNoteHead(x, y, color);
          }
        }
      }

      for (let b = 1; b <= currentBars; b++) {
        const barX = STAFF_CONTENT_START + b * (availableWidth / currentBars);
        ctx.beginPath();
        ctx.strokeStyle = "#e2e8f0";
        ctx.lineWidth = 1.5;
        ctx.moveTo(barX, topLineY);
        ctx.lineTo(barX, staffBottomY);
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.strokeStyle = "#e2e8f0";
      ctx.lineWidth = 2;
      ctx.moveTo(rightLimit, topLineY);
      ctx.lineTo(rightLimit, staffBottomY);
      ctx.stroke();

      if (harmonyEnabled && currentChords.length) {
        ctx.fillStyle = "#e2e8f0";
        ctx.font = "14px system-ui";
        const placed = [];
        for (let i = 0; i < positions.length; i++) {
          const chord = currentChords[i];
          if (!chord) continue;
          const {x, y} = positions[i];
          let chordY = Math.min(y - 20, topLineY - 18);
          if (chordY < 12) chordY = 12;
          const text = chord.symbol;
          const textW = ctx.measureText(text).width;

          for (const pc of placed) {
            if (Math.abs(x - pc.x) < Math.max(textW, pc.w) + 4) {
              chordY = pc.y - 14;
            }
          }

          ctx.fillText(text, x - 10, chordY);
          placed.push({x, y: chordY, w: textW});
        }
      }

      const triIdx = (triangleOverrideIdx !== null)
        ? triangleOverrideIdx
        : ((activeOverrideIdx !== null) ? activeOverrideIdx : currentIndex);
      const activePos = positions[triIdx];
      if (activePos) {
        ctx.beginPath();
        ctx.moveTo(activePos.x, triangleY);
        ctx.lineTo(activePos.x - 7, triangleY + 12);
        ctx.lineTo(activePos.x + 7, triangleY + 12);
        ctx.closePath();
        ctx.fillStyle = "#eab308";
        ctx.fill();
      }

      const currentEntry = currentMelody[(activeOverrideIdx !== null) ? activeOverrideIdx : currentIndex] || null;
      let noteForFret = null;
      if (typeof currentEntry === "string" && currentEntry !== "R") {
        noteForFret = currentEntry;
      } else if (currentEntry && typeof currentEntry === "object" && currentEntry.t === "hn") {
        noteForFret = currentEntry.note;
      }
      drawFretboard(noteForFret);
    }

    function updateStatusForCurrent() {
      const entry = currentMelody[currentIndex];
      if (!entry) {
        statusEl.textContent = "‚Äî";
        statusEl.className = "status mid";
        return;
      }
      if (typeof entry === "string") {
        if (entry === "R") {
          statusEl.textContent = "Silencio";
        } else {
          statusEl.textContent = "Toca: " + entry;
        }
      } else if (entry.t === "hn") {
        statusEl.textContent = "Toca (blanca): " + entry.note;
      } else if (entry.t === "hr") {
        statusEl.textContent = "Silencio (blanca)";
      } else if (entry.t === "cont") {
        statusEl.textContent = "‚Äî";
      }
      statusEl.className = "status mid";
    }

    function updateProgress() {
      progressEl.textContent = currentIndex + " / " + currentMelody.length;
    }

    async function initAudio() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({audio: true});
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        source.connect(analyser);
        dataArray = new Float32Array(analyser.fftSize);
        statusEl.textContent = "Micr√≥fono listo. Toca la nota marcada.";
        statusEl.className = "status mid";
        listen();
      } catch (err) {
        console.error(err);
        statusEl.textContent = "No se pudo acceder al micr√≥fono. Revisa permisos.";
        statusEl.className = "status bad";
      }
    }

    function createImpulse(context, seconds = 1.6, decay = 2.0) {
      const rate = context.sampleRate;
      const length = rate * seconds;
      const impulse = context.createBuffer(2, length, rate);
      for (let c = 0; c < 2; c++) {
        const chan = impulse.getChannelData(c);
        for (let i = 0; i < length; i++) {
          const t = i / length;
          const white = (Math.random() * 2 - 1) * 0.4;
          chan[i] = white * Math.pow(1 - t, decay);
        }
      }
      return impulse;
    }

    function ensureReverbNodes() {
      if (!audioContext) return;
      if (!reverbConvolver) {
        reverbConvolver = audioContext.createConvolver();
        reverbConvolver.buffer = createImpulse(audioContext, 1.7, 2.5);

        reverbLowpass = audioContext.createBiquadFilter();
        reverbLowpass.type = "lowpass";
        reverbLowpass.frequency.value = 1500;
        reverbLowpass.Q.value = 0.7;

        reverbGain = audioContext.createGain();
        reverbGain.gain.value = reverbLevel;

        reverbConvolver.connect(reverbLowpass);
        reverbLowpass.connect(reverbGain);
        reverbGain.connect(audioContext.destination);
      } else {
        reverbGain.gain.value = reverbLevel;
      }
    }

    function drawMeter(rms) {
      const w = meterCanvas.width;
      const h = meterCanvas.height;
      meterCtx.clearRect(0,0,w,h);
      meterCtx.fillStyle = "#1f2937";
      meterCtx.fillRect(0,0,w,h);

      if (!micEnabled) {
        return;
      }

      const norm = Math.min(rms / METER_MAX_RMS, 1);
      const barW = norm * w;
      meterCtx.fillStyle = "#38f8b8";
      meterCtx.fillRect(0,2,barW,h-4);

      const gateNorm = Math.min(noiseGate / METER_MAX_RMS, 1);
      const gateX = gateNorm * w;
      meterCtx.strokeStyle = "#f97316";
      meterCtx.beginPath();
      meterCtx.moveTo(gateX, 0);
      meterCtx.lineTo(gateX, h);
      meterCtx.stroke();
    }

    function scheduleRestAdvance(beats = 1) {
      if (restAdvanceTimer !== null) return;
      const noteMs = 60000 / currentBpm;
      statusEl.textContent = beats === 1 ? "Silencio" : "Silencio (blanca)";
      statusEl.className = "status good";
      restAdvanceTimer = setTimeout(() => {
        advancing = true;
        nextNote(0);
        restAdvanceTimer = null;
      }, noteMs * beats);
    }

    function listen() {
      if (!analyser) { requestAnimationFrame(listen); return; }
      analyser.getFloatTimeDomainData(dataArray);

      let rms = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const v = dataArray[i];
        rms += v * v;
      }
      rms = Math.sqrt(rms / dataArray.length);

      if (micEnabled) {
        drawMeter(rms);
      } else {
        drawMeter(0);
      }

      const curEntry = currentMelody[currentIndex];

      // avance autom√°tico de silencios
      if (!isPlaying && !advancing) {
        if (typeof curEntry === "string" && curEntry === "R") {
          scheduleRestAdvance(1);
        } else if (curEntry && typeof curEntry === "object" && curEntry.t === "hr") {
          scheduleRestAdvance(2);
        } else if (curEntry && typeof curEntry === "object" && curEntry.t === "cont") {
          advancing = true;
          nextNote(0);
        }
      }

      if (micEnabled && !isPlaying && rms > noiseGate) {
        const freq = autoCorrelate(dataArray, audioContext.sampleRate);
        if (freq !== -1) {
          checkNote(freq);
        }
      }

      requestAnimationFrame(listen);
    }

    muteBtn.onclick = () => {
      micEnabled = !micEnabled;
      muteBtn.textContent = micEnabled ? "Mute micr√≥fono" : "Unmute micr√≥fono";
      statusEl.textContent = micEnabled ? "Micr√≥fono activo." : "Micr√≥fono en mute.";
      statusEl.className = micEnabled ? "status mid" : "status bad";
      if (!micEnabled) drawMeter(0);
      lastActiveTime = Date.now();
    };

    function noteNameToFreq(noteStr) {
      const m = noteStr && typeof noteStr === "string" ? noteStr.match(/^([A-G])([#b]?)(\d)$/) : null;
      if (!m) return null;
      let [, letter, acc, octStr] = m;
      const octave = parseInt(octStr, 10);
      const baseMap = {C:0, D:2, E:4, F:5, G:7, A:9, B:11};
      let semitone = baseMap[letter];
      if (acc === "#") semitone += 1;
      if (acc === "b") semitone -= 1;
      const midi = (octave + 1) * 12 + semitone;
      return 440 * Math.pow(2, (midi - 69) / 12);
    }

    function noteNameToMidi(noteStr) {
      const m = noteStr && typeof noteStr === "string" ? noteStr.match(/^([A-G])([#b]?)(\d)$/) : null;
      if (!m) return null;
      let [, letter, acc, octStr] = m;
      const octave = parseInt(octStr, 10);
      const baseMap = {C:0, D:2, E:4, F:5, G:7, A:9, B:11};
      let semitone = baseMap[letter];
      if (acc === "#") semitone += 1;
      if (acc === "b") semitone -= 1;
      return (octave + 1) * 12 + semitone;
    }

    function playOsc(freq, dur, gainVal = 0.3) {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.type = "sine";
      osc.frequency.value = freq;
      osc.connect(gain);
      gain.connect(audioContext.destination);
      if (reverbConvolver) {
        osc.connect(reverbConvolver);
      }
      const now = audioContext.currentTime;
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(gainVal, now + 0.02);
      gain.gain.linearRampToValueAtTime(0, now + dur);
      osc.start(now);
      osc.stop(now + dur + 0.02);
    }

    function playChordWithMelody(chordObj, melodyFreq, dur = 0.45) {
      if (!chordObj) return;
      const bassOct = (currentClef === "bass") ? 2 : 3;
      const bassFreq = noteNameToFreq(chordObj.root + bassOct);
      if (bassFreq) playOsc(bassFreq, dur, 0.28);

      const tones = chordObj.tones.slice(0,3);
      for (const t of tones) {
        let f = noteNameToFreq(t + "4");
        if (!f) continue;
        while (f >= melodyFreq - 30) {
          f = f / 2;
        }
        playOsc(f, dur, 0.18);
      }
    }

    function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

    async function playOnce() {
      const quarterMs = 60000 / currentBpm;
      for (let i = 0; i < currentMelody.length; i++) {
        if (playbackAbort) break;
        const entry = currentMelody[i];
        drawAllBars(i, i);
        let durMs = quarterMs;
        let isRest = false;
        let playNote = null;
        let chord = harmonyEnabled ? currentChords[i] : null;

        if (typeof entry === "string") {
          if (entry === "R") {
            isRest = true;
            durMs = quarterMs;
          } else {
            playNote = entry;
          }
        } else if (entry && typeof entry === "object") {
          if (entry.t === "hn") {
            playNote = entry.note;
            durMs = quarterMs * 2;
          } else if (entry.t === "hr") {
            isRest = true;
            durMs = quarterMs * 2;
          } else if (entry.t === "cont") {
            // no sonido
          }
        }

        if (playNote) {
          const f = noteNameToFreq(playNote);
          if (f) {
            ensureReverbNodes();
            if (chord) {
              playChordWithMelody(chord, f, durMs/1000 * 0.85);
              playOsc(f, durMs/1000 * 0.85, 0.45);
            } else {
              playOsc(f, durMs/1000 * 0.85, 0.4);
            }
          }
        }

        lastActiveTime = Date.now();
        await sleep(durMs);
      }
    }

    playBtn.onclick = async () => {
      if (isPlaying) {
        playbackAbort = true;
        return;
      }
      if (!currentMelody.length) return;
      isPlaying = true;
      playbackAbort = false;
      lastActiveTime = Date.now();
      const prevMic = micEnabled;
      micEnabled = false;
      drawMeter(0);
      muteBtn.textContent = "Unmute micr√≥fono";
      statusEl.textContent = "Reproduciendo...";
      statusEl.className = "status mid";
      const originalIndex = currentIndex;

      do {
        await playOnce();
      } while (loopMode && !playbackAbort);

      currentIndex = originalIndex;
      drawAllBars();
      micEnabled = prevMic;
      muteBtn.textContent = micEnabled ? "Mute micr√≥fono" : "Unmute micr√≥fono";
      statusEl.textContent = micEnabled ? "Micr√≥fono activo." : "Micr√≥fono en mute.";
      statusEl.className = micEnabled ? "status mid" : "status bad";
      if (!micEnabled) drawMeter(0);
      lastActiveTime = Date.now();
      isPlaying = false;
      playbackAbort = false;
    };

    prevBtn.onclick = () => {
      if (currentIndex > 0) {
        currentIndex--;
        updateProgress();
        drawAllBars();
        updateStatusForCurrent();
      }
    };
    startBtn.onclick = () => {
      currentIndex = 0;
      updateProgress();
      drawAllBars();
      updateStatusForCurrent();
    };
    loopBtn.onclick = () => {
      loopMode = !loopMode;
      loopBtn.textContent = loopMode ? "Loop: on" : "Loop: off";
      saveSettings();
    };

    document.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        playBtn.click();
      } else if (e.key === "m" || e.key === "M") {
        e.preventDefault();
        muteBtn.click();
      } else if (e.key === "ArrowLeft") {
        e.preventDefault();
        prevBtn.click();
      } else if (e.key === "Home") {
        e.preventDefault();
        startBtn.click();
      } else if (e.key === "l" || e.key === "L") {
        e.preventDefault();
        loopBtn.click();
      }
    });

    function centsDiff(freq, target) {
      return 1200 * Math.log2(freq / target);
    }

    function checkNote(freq) {
      if (advancing || isPlaying) return;
      const entry = currentMelody[currentIndex];
      if (!entry) return;

      // si es continuaci√≥n, avanzar
      if (entry && typeof entry === "object" && entry.t === "cont") {
        advancing = true;
        nextNote(0);
        return;
      }

      // si es silencio, no se compara
      if (typeof entry === "string" && entry === "R") return;
      if (entry && typeof entry === "object" && entry.t === "hr") return;

      const targetNote = (typeof entry === "string") ? entry : (entry.note || null);
      if (!targetNote) return;

      const targetFreq = noteNameToFreq(targetNote);
      if (!targetFreq) return;
      const MAX_CENTS = 30;
      let ok = Math.abs(centsDiff(freq, targetFreq)) <= MAX_CENTS;

      if (!ok && currentInstrument === "guitar") {
        const doubled = freq * 2;
        if (Math.abs(centsDiff(doubled, targetFreq)) <= MAX_CENTS) ok = true;
      }

      if (ok) {
        statusEl.textContent = "‚úî Correcto: " + targetNote;
        statusEl.className = "status good";
        advancing = true;
        nextNote();
      } else if (freq < targetFreq) {
        statusEl.textContent = "Muy bajo‚Ä¶ s√∫belo";
        statusEl.className = "status bad";
      } else {
        statusEl.textContent = "Muy alto‚Ä¶ b√°jalo";
        statusEl.className = "status bad";
      }
    }

    function nextNote(delayMs = 400) {
      setTimeout(() => {
        currentIndex++;
        updateProgress();
        lastActiveTime = Date.now();

        if (currentIndex >= currentMelody.length) {
          exercisesDone++;
          updateStudyInfo();
          loadNewMelody();
          advancing = false;
          return;
        }

        drawAllBars();
        updateStatusForCurrent();
        advancing = false;
      }, delayMs);
    }

    function autoCorrelate(buf, sampleRate) {
      let SIZE = buf.length;
      let rms = 0;
      for (let i = 0; i < SIZE; i++) {
        let val = buf[i];
        rms += val * val;
      }
      rms = Math.sqrt(rms / SIZE);
      if (rms < noiseGate) return -1;

      let r1 = 0, r2 = SIZE - 1, thres = 0.2;
      for (let i = 0; i < SIZE/2; i++) {
        if (Math.abs(buf[i]) < thres) { r1 = i; break; }
      }
      for (let i = 1; i < SIZE/2; i++) {
        if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }
      }
      buf = buf.slice(r1, r2);
      SIZE = buf.length;
      let c = new Array(SIZE).fill(0);
      for (let i = 0; i < SIZE; i++) {
        for (let j = 0; j < SIZE - i; j++) {
          c[i] = c[i] + buf[j] * buf[j+i];
        }
      }
      let d = 0;
      while (c[d] > c[d+1]) d++;
      let maxval = -1, maxpos = -1;
      for (let i = d; i < SIZE; i++) {
        if (c[i] > maxval) {
          maxval = c[i];
          maxpos = i;
        }
      }
      let T0 = maxpos;
      let x1 = c[T0-1], x2 = c[T0], x3 = c[T0+1];
      let a = (x1 + x3 - 2*x2) / 2;
      let b = (x3 - x1) / 2;
      if (a) T0 = T0 - b/(2*a);
      return sampleRate / T0;
    }

    function applyFretboardWidth() {
      fretCanvas.width = fretboardWidth;
      fretboardBox.style.width = (fretboardWidth + FRET_LEFT_COLUMN_WIDTH) + "px";
      if (currentInstrument === "guitar") {
        const entry = currentMelody[currentIndex];
        let note = null;
        if (typeof entry === "string" && entry !== "R") note = entry;
        else if (entry && typeof entry === "object" && entry.t === "hn") note = entry.note;
        drawFretboard(note);
      }
    }

    if (fretWidthBtn) {
      fretWidthBtn.addEventListener("click", () => {
        fretboardWidthIndex = (fretboardWidthIndex + 1) % FRETBOARD_WIDTHS.length;
        fretboardWidth = FRETBOARD_WIDTHS[fretboardWidthIndex];
        applyFretboardWidth();
        saveSettings();
      });
    }

    function drawFretboard(noteStr) {
      const w = fretCanvas.width;
      const h = fretCanvas.height;

      if (currentInstrument !== "guitar") {
        return;
      }

      fretCtx.clearRect(0,0,w,h);
      fretCtx.fillStyle = "rgba(15,23,42,.2)";
      fretCtx.fillRect(0,0,w,h);

      const leftPad = FRET_CANVAS_LEFT_PAD;
      const rightPad = FRET_CANVAS_RIGHT_PAD;
      const topPad = 10;
      const bottomPad = 10;
      const usableW = w - leftPad - rightPad;
      const fretW = usableW / MAX_FRETS;

      const stringsCount = 6;
      const stringSpacing = (h - topPad - bottomPad) / (stringsCount - 1);

      for (let i = 0; i < stringsCount; i++) {
        const y = topPad + i * stringSpacing;
        fretCtx.strokeStyle = "rgba(226,232,240,.4)";
        fretCtx.lineWidth = 1;
        fretCtx.beginPath();
        fretCtx.moveTo(leftPad, y);
        fretCtx.lineTo(w - rightPad, y);
        fretCtx.stroke();
      }

      for (let f = 0; f <= MAX_FRETS; f++) {
        const x = leftPad + f * fretW;
        fretCtx.strokeStyle = "rgba(226,232,240,.3)";
        fretCtx.lineWidth = f === 0 ? 3 : 1;
        fretCtx.beginPath();
        fretCtx.moveTo(x, topPad);
        fretCtx.lineTo(x, h - bottomPad);
        fretCtx.stroke();

        if ([3,5,7,9,12].includes(f)) {
          fretCtx.fillStyle = "rgba(226,232,240,.25)";
          fretCtx.beginPath();
          fretCtx.arc(x - fretW/2, h - 18, 4, 0, Math.PI*2);
          fretCtx.fill();
        }
      }

      if (!noteStr) {
        fretCtx.fillStyle = "#94a3b8";
        fretCtx.font = "10px system-ui";
        fretCtx.fillText("Diapas√≥n", leftPad, 12);
        return;
      }

      const targetMidi = noteNameToMidi(noteStr);

      if (targetMidi !== null) {
        for (let s = 0; s < 6; s++) {
          const tuningNote = currentGuitarTuning[s] || DEFAULT_GUITAR_TUNING[s];
          const stringMidi = noteNameToMidi(tuningNote);
          if (stringMidi == null) continue;

          const fret = targetMidi - stringMidi;
          if (fret >= 0 && fret <= MAX_FRETS) {
            const y = topPad + s * stringSpacing;
            const x = leftPad + fret * fretW - fretW/2;
            fretCtx.fillStyle = "#38f8b8";
            fretCtx.beginPath();
            fretCtx.arc(x, y, 6, 0, Math.PI*2);
            fretCtx.fill();
          }
        }
      }

      fretCtx.fillStyle = "#94a3b8";
      fretCtx.font = "10px system-ui";
    }

    loadSettings();
    createTuningSelectors();
    loadNewMelody();
    initAudio();
  </script>
</body>
</html>
